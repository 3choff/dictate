<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mistral Transcription Test</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#111; color:#e8eaed; margin:0; padding:24px; }
    .card { max-width: 720px; margin: 0 auto; background:#1b1b1b; border:1px solid #333; border-radius:12px; padding:20px; }
    h1 { margin:0 0 16px; font-size:20px; }
    .row { display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    label { min-width: 120px; font-size:14px; color:#b0b0b0; }
    input[type="text"], input[type="password"], select { flex:1; min-width: 220px; padding:8px 10px; background:#222; color:#e8eaed; border:1px solid #444; border-radius:6px; }
    input[type="file"] { color:#b0b0b0; }
    button { background:#2f6feb; color:#fff; border:none; padding:10px 14px; border-radius:8px; cursor:pointer; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    .muted { color:#9aa0a6; font-size:12px; }
    pre { background:#0d0d0d; border:1px solid #333; padding:12px; border-radius:8px; overflow:auto; max-height:320px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Mistral Transcription Test</h1>
    <div class="row">
      <label for="apiKey">API Key</label>
      <input id="apiKey" type="password" placeholder="Enter your Mistral API key" />
    </div>
    <div class="row">
      <label for="audioFile">Audio File</label>
      <input id="audioFile" type="file" accept="audio/*" />
    </div>
    <div class="row">
      <label for="language">Language</label>
      <input id="language" type="text" placeholder="Optional (e.g. en). Leave empty for auto/multi" />
    </div>
    <div class="row">
      <label for="model">Model</label>
      <select id="model">
        <option value="voxtral-mini-2507" selected>voxtral-mini-2507</option>
      </select>
    </div>
    <div class="row">
      <button id="recBtn">Start recording</button>
      <span class="muted" id="recStatus">Idle</span>
    </div>
    <div class="row">
      <button id="runBtn">Transcribe file</button>
      <span class="muted">This page is isolated from the app. It uses a local proxy to avoid CORS.</span>
    </div>

    <div class="row" style="margin-top:16px;">
      <label>HTTP Status</label>
      <span id="status">-</span>
    </div>
    <div class="row" style="align-items:flex-start;">
      <label>Response</label>
      <pre id="response">(no response yet)</pre>
    </div>
    <div class="row" style="align-items:flex-start;">
      <label>Transcript</label>
      <pre id="transcript">(no transcript yet)</pre>
    </div>

    <p class="muted">Tip: If opening via file:// causes CORS issues, serve this folder via a simple local server.</p>
  </div>

  <script src="./mistral_test.js"></script>
  <script>
    const runBtn = document.getElementById('runBtn');
    const apiKeyInput = document.getElementById('apiKey');
    const fileInput = document.getElementById('audioFile');
    const languageInput = document.getElementById('language');
    const modelSelect = document.getElementById('model');
    const statusEl = document.getElementById('status');
    const responseEl = document.getElementById('response');
    const transcriptEl = document.getElementById('transcript');
    const recBtn = document.getElementById('recBtn');
    const recStatus = document.getElementById('recStatus');

    // --- Simple WAV encoder utilities (16 kHz mono) ---
    function encodeWav16kMono(int16Samples) {
      const numSamples = int16Samples.length;
      const headerSize = 44;
      const dataSize = numSamples * 2;
      const buffer = new ArrayBuffer(headerSize + dataSize);
      const view = new DataView(buffer);
      const writeString = (offset, str) => { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); };
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true); // PCM chunk size
      view.setUint16(20, 1, true);  // PCM format
      view.setUint16(22, 1, true);  // channels
      view.setUint32(24, 16000, true); // sample rate
      view.setUint32(28, 16000 * 2, true); // byte rate
      view.setUint16(32, 2, true); // block align
      view.setUint16(34, 16, true); // bits per sample
      writeString(36, 'data');
      view.setUint32(40, dataSize, true);
      let off = 44;
      for (let i = 0; i < numSamples; i++, off += 2) view.setInt16(off, int16Samples[i], true);
      return new Uint8Array(buffer);
    }

    function mixToMonoFloat32(audioBuffer) {
      const ch = audioBuffer.numberOfChannels;
      if (ch === 1) return audioBuffer.getChannelData(0);
      const len = audioBuffer.length;
      const out = new Float32Array(len);
      for (let c = 0; c < ch; c++) {
        const data = audioBuffer.getChannelData(c);
        for (let i = 0; i < len; i++) out[i] += data[i];
      }
      for (let i = 0; i < len; i++) out[i] /= ch;
      return out;
    }

    function downsampleTo16kInt16(float32Mono, inputSampleRate) {
      const targetRate = 16000;
      const ratio = inputSampleRate / targetRate;
      const newLength = Math.floor(float32Mono.length / ratio);
      const out = new Int16Array(newLength);
      let iOut = 0;
      for (let i = 0; i < newLength; i++) {
        const start = Math.floor(i * ratio);
        const end = Math.floor((i + 1) * ratio);
        let sum = 0, count = 0;
        for (let j = start; j < end && j < float32Mono.length; j++) { sum += float32Mono[j]; count++; }
        const sample = count ? (sum / count) : float32Mono[Math.min(start, float32Mono.length - 1)];
        const s = Math.max(-1, Math.min(1, sample));
        out[iOut++] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return out;
    }

    // --- Recording state ---
    let audioCtx = null;
    let mediaStream = null;
    let sourceNode = null;
    let processor = null;
    let recorded = [];
    let inputRate = 48000;

    async function startRecording() {
      recBtn.disabled = true;
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        try { await audioCtx.resume(); } catch (_) {}
        inputRate = audioCtx.sampleRate || 48000;
        sourceNode = audioCtx.createMediaStreamSource(mediaStream);
        processor = audioCtx.createScriptProcessor(4096, 1, 1);
        recorded = [];
        processor.onaudioprocess = (ev) => {
          const inBuf = ev.inputBuffer;
          const mono = mixToMonoFloat32(inBuf);
          // copy buffer chunk
          const copy = new Float32Array(mono.length);
          copy.set(mono);
          recorded.push(copy);
        };
        sourceNode.connect(processor);
        processor.connect(audioCtx.destination);
        recStatus.textContent = 'Recording...';
        recBtn.textContent = 'Stop recording';
      } catch (e) {
        alert('Microphone error: ' + (e && e.message ? e.message : String(e)));
      } finally {
        recBtn.disabled = false;
      }
    }

    async function stopRecordingAndSend() {
      recBtn.disabled = true;
      try {
        if (processor) { try { processor.disconnect(); } catch (_) {} }
        if (sourceNode) { try { sourceNode.disconnect(); } catch (_) {} }
        if (audioCtx) { try { await audioCtx.close(); } catch (_) {} }
        if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); }

        // Flatten Float32
        let total = 0; recorded.forEach(b => total += b.length);
        const all = new Float32Array(total);
        let off = 0; recorded.forEach(b => { all.set(b, off); off += b.length; });
        const int16 = downsampleTo16kInt16(all, inputRate);
        const wav = encodeWav16kMono(int16);
        const blob = new Blob([wav], { type: 'audio/wav' });

        // Send via proxy
        const apiKey = apiKeyInput.value.trim();
        const language = languageInput.value.trim() || undefined;
        const model = modelSelect.value;
        if (!apiKey) { alert('Please enter your Mistral API key'); return; }

        statusEl.textContent = 'Uploading recorded audio...';
        responseEl.textContent = '(pending)';
        transcriptEl.textContent = '';

        const form = new FormData();
        form.append('apiKey', apiKey);
        form.append('file', blob, 'recording.wav');
        form.append('model', model);
        if (language) form.append('language', language);

        const resp = await fetch('/api/mistral/transcriptions', { method: 'POST', body: form });
        const data = await resp.json();
        statusEl.textContent = String(resp.status);
        responseEl.textContent = JSON.stringify(data, null, 2);
        transcriptEl.textContent = (data && typeof data.text === 'string') ? data.text : '(no text field in response)';

      } catch (e) {
        statusEl.textContent = 'Error';
        responseEl.textContent = e && e.message ? e.message : String(e);
        transcriptEl.textContent = '';
      } finally {
        audioCtx = null; mediaStream = null; sourceNode = null; processor = null; recorded = [];
        recBtn.disabled = false;
        recBtn.textContent = 'Start recording';
        recStatus.textContent = 'Idle';
      }
    }

    async function transcribe() {
      const apiKey = apiKeyInput.value.trim();
      const file = fileInput.files[0];
      const language = languageInput.value.trim() || undefined;
      const model = modelSelect.value;

      if (!apiKey) { alert('Please enter your Mistral API key'); return; }
      if (!file) { alert('Please choose an audio file'); return; }

      runBtn.disabled = true;
      statusEl.textContent = 'Running...';
      responseEl.textContent = '(pending)';
      transcriptEl.textContent = '';

      try {
        // Use local proxy to avoid CORS (see server.js)
        const form = new FormData();
        form.append('apiKey', apiKey);
        form.append('file', file);
        form.append('model', model);
        if (language) form.append('language', language);

        const resp = await fetch('/api/mistral/transcriptions', { method: 'POST', body: form });
        const data = await resp.json();
        statusEl.textContent = String(resp.status);
        responseEl.textContent = JSON.stringify(data, null, 2);
        if (data && typeof data.text === 'string') {
          transcriptEl.textContent = data.text;
        } else {
          transcriptEl.textContent = '(no text field in response)';
        }
      } catch (e) {
        statusEl.textContent = 'Error';
        responseEl.textContent = e && e.message ? e.message : String(e);
        transcriptEl.textContent = '';
      } finally {
        runBtn.disabled = false;
      }
    }

    runBtn.addEventListener('click', transcribe);
    recBtn.addEventListener('click', () => {
      if (recBtn.textContent === 'Start recording') startRecording(); else stopRecordingAndSend();
    });
  </script>
</body>
</html>
