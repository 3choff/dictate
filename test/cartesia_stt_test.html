<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cartesia STT WebSocket Tester</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f5f6fa;
      margin: 0;
      padding: 24px;
      color: #1d1d1d;
    }
    h1 {
      margin: 0 0 10px 0;
    }
    .card {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 14px rgba(0,0,0,0.1);
      padding: 24px;
      max-width: 840px;
    }
    .row {
      display: flex;
      flex-direction: column;
      margin-bottom: 16px;
    }
    label {
      font-weight: 600;
      margin-bottom: 6px;
    }
    input, select {
      padding: 9px 11px;
      border-radius: 6px;
      border: 1px solid #ccd1da;
      font-size: 14px;
    }
    button {
      padding: 10px 18px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      margin-right: 10px;
    }
    button.primary {
      background: #3366ff;
      color: #fff;
    }
    button.secondary {
      background: #eef1f6;
      color: #333;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #status {
      font-weight: 600;
      color: #207020;
    }
    #log {
      height: 260px;
      overflow-y: auto;
      background: #111;
      color: #f4f6f9;
      padding: 12px;
      border-radius: 8px;
      font-family: Consolas, monospace;
      font-size: 13px;
      white-space: pre-wrap;
    }
    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Cartesia Streaming STT Tester</h1>
    <p style="margin-top:4px;">Isolated harness for experimenting with Cartesia's WebSocket transcription API.</p>

    <div class="row">
      <label for="apiKey">Cartesia API Key</label>
      <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" />
    </div>

    <div class="grid">
      <div class="row">
        <label for="model">Model</label>
        <select id="model">
          <option value="ink-whisper" selected>ink-whisper</option>
        </select>
      </div>
      <div class="row">
        <label for="encoding">Encoding</label>
        <select id="encoding">
          <option value="pcm_s16le" selected>pcm_s16le</option>
          <option value="pcm_s32le">pcm_s32le</option>
          <option value="pcm_f16le">pcm_f16le</option>
          <option value="pcm_f32le">pcm_f32le</option>
          <option value="pcm_mulaw">pcm_mulaw</option>
          <option value="pcm_alaw">pcm_alaw</option>
        </select>
      </div>
      <div class="row">
        <label for="sampleRate">Sample Rate (Hz)</label>
        <input id="sampleRate" type="number" value="16000" min="8000" step="1000" />
      </div>
      <div class="row">
        <label for="language">Language (optional)</label>
        <input id="language" type="text" placeholder="ISO-639-1 (e.g. en)" />
      </div>
    </div>

    <div class="row" style="flex-direction:row; align-items:center;">
      <button id="startBtn" class="primary">Start Streaming</button>
      <button id="stopBtn" class="secondary" disabled>Stop Streaming</button>
      <span id="status" style="margin-left:12px;">Idle</span>
    </div>

    <div class="row">
      <label>Transcripts</label>
      <div id="log">(no data)</div>
    </div>
  </div>

  <script>
    const CARTESIA_ENDPOINT = 'wss://api.cartesia.ai/stt/websocket';
    const CARTESIA_VERSION = '2025-04-16';

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');

    let ws = null;
    let audioContext = null;
    let mediaStream = null;
    let sourceNode = null;
    let processorNode = null;
    let transcripts = [];

    function log(message) {
      transcripts.push(message);
      if (transcripts.length > 300) transcripts.shift();
      logEl.textContent = transcripts.join('\n');
      logEl.scrollTop = logEl.scrollHeight;
    }

    function setStatus(text, color = '#207020') {
      statusEl.textContent = text;
      statusEl.style.color = color;
    }

    function setBusy(isBusy) {
      startBtn.disabled = isBusy;
      stopBtn.disabled = !isBusy;
    }

    async function startStreaming() {
      const apiKey = document.getElementById('apiKey').value.trim();
      const model = document.getElementById('model').value;
      const encoding = document.getElementById('encoding').value;
      const sampleRate = parseInt(document.getElementById('sampleRate').value, 10) || 16000;
      const language = document.getElementById('language').value.trim();

      if (!apiKey) {
        alert('Please enter your Cartesia API key.');
        return;
      }

      transcripts = [];
      log('(connecting...)');

      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        console.error(err);
        alert('Microphone access denied or unavailable.');
        return;
      }

      const query = new URLSearchParams({
        model,
        encoding,
        sample_rate: sampleRate.toString(),
        api_key: apiKey,
        cartesia_version: CARTESIA_VERSION,
      });
      if (language) {
        query.set('language', language);
      }

      ws = new WebSocket(`${CARTESIA_ENDPOINT}?${query.toString()}`);
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        setStatus('Streaming...', '#1358c4');
        log('[info] WebSocket connected.');
        setBusy(true);
        startAudioPipeline(sampleRate);
      };

      ws.onmessage = (event) => {
        if (typeof event.data === 'string') {
          try {
            const msg = JSON.parse(event.data);
            handleTranscriptionMessage(msg);
          } catch (err) {
            log('[warn] Non-JSON message: ' + event.data);
          }
        }
      };

      ws.onclose = (event) => {
        log(`[info] WebSocket closed (code=${event.code}, reason=${event.reason || 'n/a'})`);
        cleanupPipeline();
        setBusy(false);
        setStatus('Closed', '#aa2222');
      };

      ws.onerror = (err) => {
        console.error(err);
        log('[error] WebSocket error. Check console and ensure Cartesia API key / version are correct.');
        log('[hint] Browser WebSockets cannot set custom headers. Passing api_key and cartesia_version as query params is required.');
        cleanupPipeline();
        setBusy(false);
        setStatus('Error', '#aa2222');
      };
    }

    function handleTranscriptionMessage(msg) {
      if (msg.type === 'transcript') {
        const text = (msg.text || '').trim();
        if (!text.length) {
          return;
        }
        const badge = msg.is_final ? '[FINAL ]' : '[PARTIAL]';
        log(`${badge} ${text}`);
      } else if (msg.type === 'flush_done') {
        log('[info] flush_done received.');
      } else if (msg.type === 'done') {
        log('[info] done received. Closing stream...');
        stopStreaming();
      } else if (msg.type === 'error') {
        log(`[error] ${msg.message || 'Unknown error'}`);
      } else {
        log(`[info] ${JSON.stringify(msg)}`);
      }
    }

    function startAudioPipeline(sampleRate) {
      audioContext = new AudioContext({ sampleRate });
      sourceNode = audioContext.createMediaStreamSource(mediaStream);
      processorNode = audioContext.createScriptProcessor(4096, 1, 1);
      processorNode.onaudioprocess = (event) => {
        const channelData = event.inputBuffer.getChannelData(0);
        const pcm = floatTo16BitPCM(channelData);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(pcm);
        }
      };
      sourceNode.connect(processorNode);
      processorNode.connect(audioContext.destination);
    }

    function floatTo16BitPCM(float32Array) {
      const buffer = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buffer);
      for (let i = 0; i < float32Array.length; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
      return buffer;
    }

    function stopStreaming() {
      cleanupPipeline();
      if (ws) {
        if (ws.readyState === WebSocket.OPEN) {
          ws.send('finalize');
          ws.send('done');
        }
        ws.close();
        ws = null;
      }
      setBusy(false);
      setStatus('Stopped', '#aa2222');
    }

    function cleanupPipeline() {
      if (processorNode) {
        processorNode.disconnect();
        processorNode = null;
      }
      if (sourceNode) {
        sourceNode.disconnect();
        sourceNode = null;
      }
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach((track) => track.stop());
        mediaStream = null;
      }
    }

    startBtn.addEventListener('click', startStreaming);
    stopBtn.addEventListener('click', stopStreaming);

    window.addEventListener('beforeunload', () => {
      cleanupPipeline();
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send('finalize');
        ws.send('done');
        ws.close();
      }
    });
  </script>
</body>
</html>
